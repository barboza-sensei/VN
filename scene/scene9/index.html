<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Escena 9 — La Puerta Flotante</title>
  <link rel="stylesheet" href="../../style.css" />
  <style>
    /* Estilos globales y de voz, asumiendo su existencia en style.css, se mantienen solo los específicos */
    body {
        /* IMAGEN INICIAL (Puerta flotante) */
        background-image: url('assets/bg/puerta_flotante.png'); 
        background-color: #0c0c1a;
        background-size: cover;
        background-position: center;
        transition: background-image 1s ease-in-out; 
    }
    
    .resaltado {
        font-weight: bold;
        color: #f0f0f0; 
        text-shadow: 0 0 5px rgba(255, 255, 255, 0.4);
    }
    
    /* Estilos estéticos de la caja de diálogo y botones para coherencia */
    #main-dialogue-box {
        position: absolute; bottom: 5vh; left: 50%; transform: translateX(-50%);
        width: 90%; max-width: 800px; padding: 1.5em;
        background-color: rgba(15, 15, 15, 0.9); 
        border: 1px solid rgba(255, 255, 255, 0.1); 
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.4); border-radius: 5px;
    }
    #choices { display: flex; flex-direction: column; gap: 0; margin-top: 15px; }
    .choice-btn {
        background: rgba(0, 0, 0, 0.4); border: none; border-radius: 0; color: #f0f0f0;
        padding: 12px 15px; font-size: 1.1em; text-align: left; transition: all 0.2s ease;
        cursor: pointer; border-bottom: 1px solid rgba(255, 255, 255, 0.1); 
    }
    .choice-btn:hover, .choice-btn:focus {
        background: rgba(40, 40, 40, 0.6); box-shadow: 0 0 0 1px #aaffff; color: #aaffff; outline: none; 
    }
    #choices .choice-btn:last-child { border-bottom: none; }
    #nextBtn::after { content: none !important; visibility: hidden; }
    #nextBtn { text-indent: 0; overflow: visible; }

    /* COLORES DE VOZ */
    .equalis-voice { color: #aaffff; text-shadow: 0 0 5px rgba(170, 255, 255, 0.4); } 
    .disparia-voice { color: #ff9999; text-shadow: 0 0 5px rgba(255, 153, 153, 0.4); } 
    .old-man-voice { color: #ffcc66; text-shadow: 0 0 5px rgba(255, 204, 102, 0.4); } 
    /* NUEVO: Color para la voz de Equalis/Disparia fusionada */
    .dual-voice { color: #E0BBE4; text-shadow: 0 0 8px rgba(224, 187, 228, 0.7); font-style: italic; }
  </style>
</head>

<body>
  <div class="dialogue-box" id="main-dialogue-box">
    <p id="text"></p>
    
    <div id="choices"></div>
    <button id="nextBtn" title="Continuar">➤</button> 
  </div>

  <script>
    let score = parseInt(localStorage.getItem('score') || 0);

    // Variable de estado para manejar las fases del desafío
    let challengeState = 0; // 0: Líneas narrativas, 1: Desafío de Precisión, 2: Desafío de Amplitud, 3: Elección Final
    
    // --- DATA DEL DESAFÍO EN FASES (Precisión Matemática Requerida) ---
    const challengeData = {
        // Fase 1: Cerradura de Precisión (Igualdad / Finito y Discreto)
        phase1: {
            question: "Al referirse a la **Cerradura de Precisión (Igualdad)**, ¿cuál es la naturaleza de su conjunto solución en la recta real?",
            answer: "Es un conjunto de soluciones finito y discreto, compuesto por elementos puntuales.",
            success: "Equalis: **La Lógica es firme.** Has definido el **Punto** único. La Precisión está satisfecha. (+1 Lógica).",
            failure: "Equalis: La verdad se te ha escurrido. El **Punto** exige una definición discreta. (-1 Lógica).",
            choices: [
                { text: "Es un conjunto infinito y continuo, representado por un intervalo cerrado.", isCorrect: false },
                { text: "Es un conjunto de soluciones finito y discreto, compuesto por elementos puntuales.", isCorrect: true },
                { text: "Es un conjunto que solo contiene soluciones enteras.", isCorrect: false }
            ]
        },
        // Fase 2: Cerradura de Amplitud (Desigualdad / Infinito y Continuo)
        phase2: {
            question: "Al referirse a la **Cerradura de Amplitud (Desigualdad)**, ¿cuál es la naturaleza de su conjunto solución en la recta real?",
            answer: "Es un conjunto de soluciones infinito y continuo, representado por un intervalo o rayo.",
            success: "Disparia: **El Caos te sonríe.** Has abrazado la naturaleza del **Rango** infinito. (+1 Lógica).",
            failure: "Disparia: ¡Qué aburrido! Confundiste el **Rango** con un simple punto. El desorden es continuo. (-1 Lógica).",
            choices: [
                { text: "Es un conjunto de soluciones finito y discreto, compuesto por un solo elemento puntual.", isCorrect: false },
                { text: "Es un conjunto infinito, pero solo incluye los números enteros dentro de un rango dado.", isCorrect: false },
                { text: "Es un conjunto de soluciones infinito y continuo, representado por un intervalo o rayo.", isCorrect: true }
            ]
        },
        // Fase 3: Elección Final (Bifurcación Narrativa)
        finalChoice: {
            question: "Tu destino final pende de esta elección: ¿Qué principio regirá tu salida?",
            transitionA: { text: "Aceptas el Destino Singular. La Cerradura de Precisión se ilumina.", nextScene: "../scene_final/ending_equalis.html" },
            transitionB: { text: "Aceptas el Camino Infinito. La Cerradura de Amplitud se enciende.", nextScene: "../scene_final/ending_disparia.html" },
            choices: [
                { text: "Elijo la **Precisión** de la Igualdad (El Punto / Destino Singular).", isChoiceA: true },
                { text: "Elijo la **Amplitud** de la Desigualdad (El Rango / Camino Infinito).", isChoiceB: true }
            ]
        }
    };

    // --- DATA DE LA ESCENA 9 (Diálogos) ---
    const scene9 = {
        id: 9,
        title: "La Puerta Flotante",
        text: [
            { type: 'narrative', content: "Salís del túnel y te encontrás en medio de una calle desierta que termina abruptamente en una **Puerta Flotante**, sostenida por ninguna estructura visible."},
            { type: 'narrative', content: "La puerta exhibe dos cerraduras: la **Cerradura de Precisión**, con un orificio exacto, y la **Cerradura de Amplitud**, con una ranura ancha. Ambas te exigen comprensión."},
            { type: 'voice', speaker: 'Equalis', content: "La **Cerradura de Precisión** exige el **Punto**. Es la **Igualdad**. Define la naturaleza de su solución."},
            { type: 'internal', content: 'Preparando desafío 1' } 
        ]
    };
    
    // Transiciones narrativas entre fases (AJUSTADAS)
    const narrativeTransition = [
        // Después de Fase 1 (Precisión) -> Diálogo de Disparia para presentar el segundo desafío
        { state: 1, content: [
            { type: 'voice', speaker: 'Disparia', content: "¡Ahora mira aquí! La **Cerradura de Amplitud** exige el **Rango**. Es la **Desigualdad**. Define la naturaleza de su solución."}
        ]},
        // Después de Fase 2 (Amplitud) -> Diálogo de la Voz Dual para la Elección Final
        { state: 2, content: [
            // El mensaje de la voz dual ahora es puramente confirmatorio
            { type: 'voice', speaker: 'Equalis/Disparia', content: "La voz dual resuena: Has comprendido la verdad de ambas cerraduras. La Puerta Flotante está lista para abrirse. **Tu elección definirá tu Destino.**"}
        ]}
    ];

    const textEl = document.getElementById("text");
    const choicesEl = document.getElementById("choices");
    const nextBtn = document.getElementById("nextBtn");
    
    let currentLine = 0; 
    const sceneData = scene9.text; 

    function formatText(content) {
        return content.replace(/\*\*(.*?)\*\*/g, '<span class="resaltado">$1</span>');
    }
    
    function changeBackground(imageUrl) {
        document.body.style.backgroundImage = `url('${imageUrl}')`;
    }

    function showLine() {
        if (currentLine >= sceneData.length) return;
        
        const lineData = sceneData[currentLine];
        textEl.className = 'fade-text'; 

        if (lineData.type === 'internal') {
            startChallenge();
            return;
        }
        
        let content = formatText(lineData.content);
        let speaker = lineData.speaker;
        
        if (speaker) {
            let voiceClass;
            if (speaker.toLowerCase() === 'equalis') { voiceClass = 'equalis-voice'; } 
            else if (speaker.toLowerCase() === 'disparia') { voiceClass = 'disparia-voice'; } 
            else if (speaker.toLowerCase() === 'equalis/disparia') { voiceClass = 'dual-voice'; } 
            else { voiceClass = 'resaltado'; }
            
            // La clase de voz es necesaria para que el CSS aplique el estilo de barra vertical
            textEl.innerHTML = `<p class="voice-line ${voiceClass}"><span class="speaker-name">${speaker}:</span> ${content}</p>`;
            
        } else {
            textEl.innerHTML = `<p>${content}</p>`;
        }
        
        nextBtn.style.display = 'inline-flex';
        void textEl.offsetWidth; 
    }

    let transitionLineIndex = 0;

    function startChallenge() {
        challengeState++;
        nextBtn.style.display = 'none';
        transitionLineIndex = 0; 

        if (challengeState === 1) {
            // Fase 1: Precisión
            renderChallengePhase(challengeData.phase1.question, challengeData.phase1.choices, 1);
        } else if (challengeState === 2) {
            // Fase 2: Amplitud
            renderChallengePhase(challengeData.phase2.question, challengeData.phase2.choices, 2);
        } else if (challengeState === 3) {
            // Fase 3: Elección Final
            renderFinalChoice(challengeData.finalChoice.question, challengeData.finalChoice.choices);
        }
    }

    function renderChallengePhase(question, choices, phase) {
        textEl.innerHTML = `<p class="challenge-question fade-text">${formatText(question)}</p>`;
        choicesEl.innerHTML = "";
        
        choices.forEach(choice => {
            const btn = document.createElement("button");
            // Aplicar formatText al texto de la opción para el resaltado
            btn.innerHTML = formatText(choice.text); 
            btn.className = 'choice-btn'; 
            const answerText = (phase === 1) ? challengeData.phase1.answer : challengeData.phase2.answer;
            btn.onclick = () => checkAnswer(choice.text, phase, answerText); 
            choicesEl.appendChild(btn);
        });
    }

    function checkAnswer(userAnswerText, phase, correctAnswer) {
        Array.from(choicesEl.children).forEach(btn => btn.disabled = true);
        
        const isCorrect = userAnswerText === correctAnswer;
        let resultText;
        let speaker;
        let voiceClass;
        
        if (isCorrect) {
            score += 1;
            speaker = (phase === 1) ? 'Equalis' : 'Disparia';
            resultText = (phase === 1) ? challengeData.phase1.success : challengeData.phase2.success;
        } else {
            score -= 1;
            speaker = (phase === 1) ? 'Equalis' : 'Disparia';
            resultText = (phase === 1) ? challengeData.phase1.failure : challengeData.phase2.failure;
        }
        
        voiceClass = (speaker.toLowerCase() === 'equalis') ? 'equalis-voice' : 'disparia-voice';
        
        // Aplicar la estructura de voz estándar
        textEl.innerHTML = `<p class="voice-line ${voiceClass}"><span class="speaker-name">${speaker}:</span> ${formatText(resultText)}</p>`;
        choicesEl.innerHTML = ''; 
        
        nextBtn.style.display = 'inline-flex';
        nextBtn.onclick = handleTransition;
    }

    function handleTransition() {
        const transition = narrativeTransition.find(t => t.state === challengeState);
        
        if (transition && transitionLineIndex < transition.content.length) {
            const lineData = transition.content[transitionLineIndex];
            
            let content = formatText(lineData.content);
            let speaker = lineData.speaker;
            
            let voiceClass;
            if (speaker.toLowerCase() === 'equalis') { voiceClass = 'equalis-voice'; } 
            else if (speaker.toLowerCase() === 'disparia') { voiceClass = 'disparia-voice'; } 
            else if (speaker.toLowerCase() === 'equalis/disparia') { voiceClass = 'dual-voice'; }
            else { voiceClass = 'resaltado'; }

            // Aplicar la estructura de voz estándar a las transiciones
            textEl.innerHTML = `<p class="voice-line ${voiceClass}"><span class="speaker-name">${speaker}:</span> ${content}</p>`;
            
            transitionLineIndex++;
            nextBtn.style.display = 'inline-flex';
        } else {
            startChallenge();
        }
    }


    function renderFinalChoice(question, choices) {
        textEl.innerHTML = `<p class="challenge-question fade-text">${formatText(question)}</p>`;
        choicesEl.innerHTML = "";
        
        // Mensaje de voz dual neutro (sin sugerencias de puntaje)
        const neutralMessage = "Equalis/Disparia: Es hora de elegir la verdad que te define.";
        
        textEl.innerHTML += `<p class="voice-line dual-voice"><span class="speaker-name">Equalis/Disparia:</span> ${formatText(neutralMessage)}</p>`;
        
        choices.forEach(choice => {
            const btn = document.createElement("button");
            btn.innerHTML = formatText(choice.text); 
            btn.className = 'choice-btn'; 
            btn.onclick = () => handleFinalChoice(choice); 
            choicesEl.appendChild(btn);
        });
    }

    function handleFinalChoice(choice) {
        Array.from(choicesEl.children).forEach(btn => btn.disabled = true);
        
        let transitionData;
        if (choice.isChoiceA) {
            transitionData = challengeData.finalChoice.transitionA;
        } else {
            transitionData = challengeData.finalChoice.transitionB;
        }

        textEl.innerHTML = transitionData.text; 
        choicesEl.innerHTML = ''; 
        
        nextBtn.style.display = 'inline-flex';
        nextBtn.onclick = () => {
            localStorage.setItem('score', score); 
            goTo(transitionData.nextScene);
        };
    }

    function goTo(relativePath) {
        const base = window.location.href.substring(0, window.location.href.lastIndexOf('/') + 1);
        const resolved = new URL(relativePath, base).href;
        window.location.href = resolved;
    }
    
    nextBtn.addEventListener("click", () => {
      if (challengeState === 0) {
          currentLine++;
          showLine();
      }
    });
    
    window.onload = showLine;
  </script>
</body>
</html>
